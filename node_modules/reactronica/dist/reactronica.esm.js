import React, { useEffect, useRef, useState, useContext } from 'react';
import StartAudioContext from 'startaudiocontext';
import Tone from 'tone';
import equal from 'fast-deep-equal';

var SongContext = /*#__PURE__*/React.createContext({
  isPlaying: false
});

var Song = function Song(_ref) {
  var _ref$isPlaying = _ref.isPlaying,
      isPlaying = _ref$isPlaying === void 0 ? false : _ref$isPlaying,
      _ref$bpm = _ref.bpm,
      bpm = _ref$bpm === void 0 ? 90 : _ref$bpm,
      _ref$swing = _ref.swing,
      swing = _ref$swing === void 0 ? 0 : _ref$swing,
      _ref$swingSubdivision = _ref.swingSubdivision,
      swingSubdivision = _ref$swingSubdivision === void 0 ? '8n' : _ref$swingSubdivision,
      _ref$volume = _ref.volume,
      volume = _ref$volume === void 0 ? 0 : _ref$volume,
      _ref$isMuted = _ref.isMuted,
      isMuted = _ref$isMuted === void 0 ? false : _ref$isMuted,
      children = _ref.children;
  useEffect(function () {
    document.body.addEventListener('click', function () {
      // iOS Web Audio API requires this library.
      StartAudioContext(Tone.context);
    }, {
      once: true
    });
  }, []);
  useEffect(function () {
    Tone.Transport.bpm.value = bpm;
    Tone.Transport.swing = swing;
    Tone.Transport.swingSubdivision = swingSubdivision;
  }, [bpm, swing, swingSubdivision]);
  useEffect(function () {
    if (isPlaying) {
      // Hack to get Tone to NOT use same settings from another instance
      Tone.Transport.bpm.value = bpm;
      Tone.Transport.swing = swing;
      Tone.Transport.swingSubdivision = swingSubdivision;
      Tone.Transport.start();
    } else {
      Tone.Transport.stop();
    }
    /* eslint-disable-next-line */

  }, [isPlaying]);
  useEffect(function () {
    Tone.Master.volume.value = volume;
  }, [volume]);
  useEffect(function () {
    Tone.Master.mute = isMuted;
  }, [isMuted]);

  if (typeof window === 'undefined') {
    return null;
  }

  return React.createElement(SongContext.Provider, {
    value: {
      isPlaying: isPlaying
    }
  }, children);
};

function buildSequencerStep(step, i) {
  if (typeof step === 'string') {
    return {
      notes: [{
        name: step
      }],
      index: i
    };
  } else if (step && step.name) {
    return {
      notes: [{
        name: step.name,
        duration: step.duration,
        velocity: step.velocity
      }],
      index: i
    };
  } else if (Array.isArray(step)) {
    return {
      notes: step.map(function (s) {
        if (typeof s === 'string') {
          return {
            name: s
          };
        }

        return s;
      }),
      index: i
    };
  }

  return {
    notes: [],
    index: i
  };
}

function usePrevious(value) {
  // The ref object is a generic container whose current property is mutable ...
  // ... and can hold any value, similar to an instance property on a class
  var ref = useRef(); // Store current value in ref

  useEffect(function () {
    ref.current = value;
  }, [value]); // Only re-run if value changes
  // Return previous value (happens before update in useEffect above)

  return ref.current;
}

var TrackContext = /*#__PURE__*/React.createContext({
  volume: 0,
  pan: 0,
  mute: false,
  solo: false,
  effectsChain: null,
  onInstrumentsUpdate: null,
  onAddToEffectsChain: null,
  onRemoveFromEffectsChain: null
});

var TrackConsumer = function TrackConsumer(_ref) {
  var isPlaying = _ref.isPlaying,
      _ref$steps = _ref.steps,
      steps = _ref$steps === void 0 ? [] : _ref$steps,
      _ref$volume = _ref.volume,
      volume = _ref$volume === void 0 ? 0 : _ref$volume,
      _ref$pan = _ref.pan,
      pan = _ref$pan === void 0 ? 0 : _ref$pan,
      mute = _ref.mute,
      solo = _ref.solo,
      _ref$subdivision = _ref.subdivision,
      subdivision = _ref$subdivision === void 0 ? '4n' : _ref$subdivision,
      _ref$effects = _ref.effects,
      effects = _ref$effects === void 0 ? [] : _ref$effects,
      children = _ref.children,
      onStepPlay = _ref.onStepPlay;

  var _useState = useState([]),
      effectsChain = _useState[0],
      setEffectsChain = _useState[1];

  var _useState2 = useState([]),
      instruments = _useState2[0],
      setInstruments = _useState2[1];

  var sequencer = useRef();
  var instrumentsRef = useRef(instruments);
  useEffect(function () {
    instrumentsRef.current = instruments;
  }, [instruments]);
  /*
  Tone.Sequence can't easily play chords. By default, arrays within steps are flattened out and subdivided. However an array of notes is our preferred way of representing chords. To get around this, buildSequencerStep() will transform notes and put them in a notes field as an array. We can then loop through and run triggerAttackRelease() to play the note/s.
  */

  var sequencerSteps = steps.map(buildSequencerStep);
  var prevSequencerSteps = usePrevious(sequencerSteps);
  useEffect(function () {
    // -------------------------------------------------------------------------
    // STEPS
    // -------------------------------------------------------------------------
    // Start/Stop sequencer!
    if (isPlaying) {
      var _sequencer$current;

      sequencer.current = new Tone.Sequence(function (_, step) {
        step.notes.forEach(function (note) {
          instrumentsRef.current.forEach(function (instrument) {
            instrument.triggerAttackRelease(note.name, note.duration || 0.5, undefined, note.velocity);
          });
        });

        if (typeof onStepPlay === 'function') {
          onStepPlay(step.notes, step.index);
        }
      }, sequencerSteps, subdivision);
      (_sequencer$current = sequencer.current) === null || _sequencer$current === void 0 ? void 0 : _sequencer$current.start(0);
    } else {
      if (sequencer.current) {
        sequencer.current.stop();
      }
    }
    /* eslint-disable-next-line */

  }, [isPlaying]);
  useEffect(function () {
    if (sequencer.current) {
      if ((prevSequencerSteps === null || prevSequencerSteps === void 0 ? void 0 : prevSequencerSteps.length) === sequencerSteps.length) {
        // When steps length is the same, update steps in a more efficient way
        sequencerSteps.forEach(function (step, i) {
          var isEqual = equal(sequencerSteps[i].notes, prevSequencerSteps && prevSequencerSteps[i] ? prevSequencerSteps[i].notes : []);

          if (!isEqual) {
            var _sequencer$current2, _sequencer$current3;

            (_sequencer$current2 = sequencer.current) === null || _sequencer$current2 === void 0 ? void 0 : _sequencer$current2.remove(i);
            (_sequencer$current3 = sequencer.current) === null || _sequencer$current3 === void 0 ? void 0 : _sequencer$current3.add(i, step);
          }
        });
      } else {
        // When new steps are less or more then prev, remove all and add new steps
        sequencer.current.removeAll();
        sequencerSteps.forEach(function (step, i) {
          sequencer.current.add(i, step);
        });
      }
    }
    /* eslint-disable-next-line */

  }, [JSON.stringify(sequencerSteps)]);
  useEffect(function () {
    return function cleanup() {
      if (sequencer.current) {
        sequencer.current.dispose();
      }
    };
  }, []);

  var handleAddToEffectsChain = function handleAddToEffectsChain(effect) {
    // console.log('<Track />', 'onAddToEffectsChain');
    setEffectsChain(function (prevEffectsChain) {
      return [effect].concat(prevEffectsChain);
    });
  };

  var handleRemoveFromEffectsChain = function handleRemoveFromEffectsChain(effect) {
    // console.log('<Track />', 'onRemoveFromEffectsChain', effect);
    setEffectsChain(function (prevEffectsChain) {
      return prevEffectsChain.filter(function (e) {
        return e.id !== effect.id;
      });
    });
  };

  var handleInstrumentsUpdate = function handleInstrumentsUpdate(newInstruments) {
    setInstruments(newInstruments);
  };

  return React.createElement(TrackContext.Provider, {
    value: {
      effectsChain: effectsChain,
      pan: pan,
      volume: volume,
      mute: mute,
      solo: solo,
      onInstrumentsUpdate: handleInstrumentsUpdate,
      onAddToEffectsChain: handleAddToEffectsChain,
      onRemoveFromEffectsChain: handleRemoveFromEffectsChain
    }
  }, children, effects);
};

var Track = function Track(props) {
  var _React$useContext = React.useContext(SongContext),
      isPlaying = _React$useContext.isPlaying;

  if (typeof window === 'undefined') {
    return null;
  }

  return React.createElement(TrackConsumer, Object.assign({
    isPlaying: isPlaying
  }, props));
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var InstrumentConsumer = function InstrumentConsumer(_ref) {
  var _ref$type = _ref.type,
      type = _ref$type === void 0 ? 'synth' : _ref$type,
      options = _ref.options,
      _ref$polyphony = _ref.polyphony,
      polyphony = _ref$polyphony === void 0 ? 4 : _ref$polyphony,
      oscillator = _ref.oscillator,
      envelope = _ref.envelope,
      _ref$notes = _ref.notes,
      notes = _ref$notes === void 0 ? [] : _ref$notes,
      samples = _ref.samples,
      onLoad = _ref.onLoad,
      volume = _ref.volume,
      pan = _ref.pan,
      mute = _ref.mute,
      solo = _ref.solo,
      effectsChain = _ref.effectsChain,
      onInstrumentsUpdate = _ref.onInstrumentsUpdate;
  var instrumentRef = useRef(); // const trackChannelBase = useRef(new Tone.PanVol(pan, volume));
  // const trackChannelBase = useRef(new Tone.Channel(volume, pan));

  var trackChannelBase = useRef(null);
  var prevNotes = usePrevious(notes); // -------------------------------------------------------------------------
  // CHANNEL
  // TODO: Consider moving this to <Track>
  // -------------------------------------------------------------------------

  useEffect(function () {
    trackChannelBase.current = new Tone.Channel(volume, pan);
    return function cleanup() {
      if (trackChannelBase.current) {
        trackChannelBase.current.dispose();
      }
    };
    /* eslint-disable-next-line */
  }, []); // -------------------------------------------------------------------------
  // INSTRUMENT TYPE
  // -------------------------------------------------------------------------

  var prevType = usePrevious(type);
  useEffect(function () {
    var _instrumentRef$curren;

    if (type === 'sampler') {
      instrumentRef.current = new Tone.Sampler(samples, onLoad);

      if (options && options.curve) {
        instrumentRef.current.curve = options.curve;
      }

      if (options && options.release) {
        instrumentRef.current.release = options.release;
      }
    } else if (type === 'membraneSynth') {
      instrumentRef.current = new Tone.MembraneSynth(buildSynthOptions({
        oscillator: oscillator,
        envelope: envelope
      }));
    } else if (type === 'metalSynth') {
      instrumentRef.current = new Tone.MetalSynth();
    } else if (type === 'noiseSynth') {
      instrumentRef.current = new Tone.NoiseSynth();
    } else if (type === 'pluckSynth') {
      instrumentRef.current = new Tone.PluckSynth();
    } else {
      var synth;

      if (type === 'amSynth') {
        synth = Tone.AMSynth;
      } else if (type === 'duoSynth') {
        synth = Tone.DuoSynth;
      } else if (type === 'fmSynth') {
        synth = Tone.FMSynth;
      } else if (type === 'monoSynth') {
        synth = Tone.MonoSynth;
      } else if (type === 'synth') {
        synth = Tone.Synth;
      } else {
        synth = Tone.Synth;
      }
      /**
       * PolySynth accepts other Synth types as second param, making them
       * polyphonic. As this is a common use case, all Synths will be created
       * via PolySynth. Monophonic synths can easily be created by setting the
       * `polyphony` prop to 1.
       */


      instrumentRef.current = new Tone.PolySynth(polyphony, synth, buildSynthOptions({
        oscillator: oscillator,
        envelope: envelope
      }));
    }

    (_instrumentRef$curren = instrumentRef.current).chain.apply(_instrumentRef$curren, effectsChain.concat([trackChannelBase.current, Tone.Master])); // Add this Instrument to Track Context


    onInstrumentsUpdate([instrumentRef.current]);
    return function cleanup() {
      if (instrumentRef.current) {
        instrumentRef.current.dispose();
      }
    };
    /* eslint-disable-next-line */
  }, [type, polyphony]);
  useEffect(function () {
    if ( // TODO: Add other synth types
    type === 'synth' && instrumentRef && instrumentRef.current && oscillator) {
      instrumentRef.current.set('oscillator', oscillator); // console.log(oscillator);
    }
  }, [oscillator, type]); // -------------------------------------------------------------------------
  // VOLUME / PAN / MUTE / SOLO
  // -------------------------------------------------------------------------

  useEffect(function () {
    trackChannelBase.current.volume.value = volume;
  }, [volume]);
  useEffect(function () {
    trackChannelBase.current.pan.value = pan;
  }, [pan]);
  useEffect(function () {
    trackChannelBase.current.mute = mute;
  }, [mute]);
  useEffect(function () {
    trackChannelBase.current.solo = solo;
  }, [solo]); // -------------------------------------------------------------------------
  // NOTES
  // -------------------------------------------------------------------------

  /**
   NOTE: Would prefer to use useLayoutEffect as it is a little faster, but unable to test it right now
   **/

  useEffect(function () {
    // Loop through all current notes
    notes && notes.forEach(function (note) {
      // Check if note is playing
      var isPlaying = prevNotes && prevNotes.filter(function (prevNote) {
        // Check both note name and unique key.
        // Key helps differentiate same notes, otherwise it won't trigger
        return prevNote.name === note.name && prevNote.key === note.key;
      }).length > 0; // Only play note is it isn't already playing

      if (!isPlaying) {
        if (note.duration) {
          instrumentRef.current.triggerAttackRelease(note.name, note.duration, undefined, note.velocity);
        } else {
          instrumentRef.current.triggerAttack(note.name, undefined, note.velocity);
        }
      }
    }); // Loop through all previous notes

    prevNotes && prevNotes.forEach(function (note) {
      // Check if note is still playing
      var isPlaying = notes && notes.filter(function (n) {
        return n.name === note.name;
      }).length > 0;

      if (!isPlaying) {
        instrumentRef.current.triggerRelease(note.name);
      }
    });
  }, [notes, prevNotes]); // -------------------------------------------------------------------------
  // EFFECTS CHAIN
  // -------------------------------------------------------------------------

  useEffect(function () {
    var _instrumentRef$curren2;

    // NOTE: Using trackChannelBase causes effects to not turn off
    instrumentRef.current.disconnect();

    (_instrumentRef$curren2 = instrumentRef.current).chain.apply(_instrumentRef$curren2, effectsChain.concat([trackChannelBase.current, Tone.Master]));
  }, [effectsChain]); // -------------------------------------------------------------------------
  // SAMPLES
  // Run whenever `samples` change, using Tone.Sampler's `add` method to load
  // more samples after initial mount
  // TODO: Check if first mount, as sampler constructor has already loaded samples
  // -------------------------------------------------------------------------

  var prevSamples = usePrevious(samples);
  useEffect(function () {
    // When sampler is initiated, it already loads samples.
    // We'll use !isFirstSamplerInit to skip adding samples if sampler has been
    // initiated in this render.
    var isFirstSamplerInit = type === 'sampler' && prevType !== type;

    if (type === 'sampler' && Boolean(samples) && !isFirstSamplerInit) {
      // const isEqual = equal(samples, prevSamples);
      var prevSampleKeys = Object.keys(prevSamples);
      var sampleKeys = Object.keys(samples); // Samples to add

      var addSampleKeys = sampleKeys.filter(function (key) {
        return !prevSampleKeys.includes(key);
      }); // Samples to remove
      // const removeSampleKeys = prevSampleKeys.filter(
      //   (key) => !sampleKeys.includes(key),
      // );
      // console.log(addSampleKeys, removeSampleKeys);

      if (addSampleKeys.length) {
        // Create an array of promises from `samples`
        var loadSamplePromises = addSampleKeys.map(function (key) {
          return new Promise(function (resolve) {
            var sample = samples[key];
            var prevSample = prevSamples ? prevSamples[key] : ''; // Only update sample if different than before

            if (sample !== prevSample) {
              // Pass `resolve` to `onLoad` parameter of Tone.Sampler
              // When sample loads, this promise will resolve
              instrumentRef.current.add(key, sample, resolve);
            } else {
              resolve(null);
            }
          });
        }); // Once all promises in array resolve, run onLoad callback

        Promise.all(loadSamplePromises).then(function (event) {
          if (typeof onLoad === 'function') {
            onLoad(event);
          }
        }); // TODO: Work out a way to remove samples. Below doesn't work
        // removeSampleKeys.forEach((key) => {
        //   instrumentRef.current.add(key, null);
        // });
      }
    }
    /* eslint-disable-next-line */

  }, [samples, type]);
  return null;
};

var Instrument = function Instrument(_ref2) {
  var type = _ref2.type,
      options = _ref2.options,
      notes = _ref2.notes,
      polyphony = _ref2.polyphony,
      oscillator = _ref2.oscillator,
      envelope = _ref2.envelope,
      samples = _ref2.samples,
      onLoad = _ref2.onLoad;

  var _useContext = useContext(TrackContext),
      volume = _useContext.volume,
      pan = _useContext.pan,
      mute = _useContext.mute,
      solo = _useContext.solo,
      effectsChain = _useContext.effectsChain,
      onInstrumentsUpdate = _useContext.onInstrumentsUpdate;

  if (typeof window === 'undefined') {
    return null;
  }

  return React.createElement(InstrumentConsumer // <Instrument /> Props
  , {
    // <Instrument /> Props
    type: type,
    options: options,
    notes: notes,
    polyphony: polyphony,
    oscillator: oscillator,
    envelope: envelope,
    samples: samples,
    onLoad: onLoad,
    // <Track /> Props
    volume: volume,
    pan: pan,
    mute: mute,
    solo: solo,
    effectsChain: effectsChain,
    onInstrumentsUpdate: onInstrumentsUpdate
  });
};
/**
 * Use Instrument's flattened synth props to create options object for Tone JS
 */


var buildSynthOptions = function buildSynthOptions(_ref3) {
  var oscillator = _ref3.oscillator,
      envelope = _ref3.envelope;

  if (oscillator || envelope) {
    return _extends({}, envelope ? {
      envelope: envelope
    } : {}, oscillator ? {
      oscillator: oscillator
    } : {});
  }

  return undefined;
};

var EffectConsumer = function EffectConsumer(_ref) {
  var type = _ref.type,
      id = _ref.id,
      _ref$delayTime = _ref.delayTime,
      delayTime = _ref$delayTime === void 0 ? '8n' : _ref$delayTime,
      _ref$feedback = _ref.feedback,
      feedback = _ref$feedback === void 0 ? 0.5 : _ref$feedback,
      _ref$wet = _ref.wet,
      wet = _ref$wet === void 0 ? 1 : _ref$wet,
      low = _ref.low,
      mid = _ref.mid,
      high = _ref.high,
      lowFrequency = _ref.lowFrequency,
      highFrequency = _ref.highFrequency,
      onAddToEffectsChain = _ref.onAddToEffectsChain,
      onRemoveFromEffectsChain = _ref.onRemoveFromEffectsChain;
  var effect = useRef();
  useEffect(function () {
    // console.log('<Effect /> mount');
    // console.log(`id: ${id}`);
    if (type === 'autoFilter') {
      effect.current = new Tone.AutoFilter();
    } else if (type === 'autoPanner') {
      effect.current = new Tone.AutoPanner();
    } else if (type === 'autoWah') {
      effect.current = new Tone.AutoWah();
    } else if (type === 'bitCrusher') {
      effect.current = new Tone.BitCrusher(); // Removed for now because delayTime has to be in ms
      // } else if (type === 'chorus') {
      //   effect.current = new Tone.Chorus();
    } else if (type === 'distortion') {
      effect.current = new Tone.Distortion(0.5);
    } else if (type === 'feedbackDelay') {
      effect.current = new Tone.FeedbackDelay(delayTime, feedback);
    } else if (type === 'freeverb') {
      effect.current = new Tone.Freeverb();
    } else if (type === 'panVol') {
      effect.current = new Tone.PanVol(); // Needs generate()
      // } else if (type === 'reverb') {
      //   effect.current = new Tone.Reverb();
    } else if (type === 'tremolo') {
      effect.current = new Tone.Tremolo();
    } else if (type === 'eq3') {
      effect.current = new Tone.EQ3(low, mid, high);
    }

    if (effect.current) {
      effect.current.id = id; // Update effects chain
      // TODO: Work out which index to insert current this.effect

      onAddToEffectsChain(effect.current);
    }

    return function () {
      // console.log('<Effect /> unmount');
      onRemoveFromEffectsChain(effect.current);
    };
    /* eslint-disable-next-line */
  }, [type]);
  useEffect(function () {
    if (effect.current && effect.current.feedback) {
      effect.current.feedback.value = feedback;
    }
  }, [feedback]);
  useEffect(function () {
    if (effect.current && effect.current.delayTime) {
      effect.current.delayTime.value = delayTime;
    }
  }, [delayTime]);
  useEffect(function () {
    if (effect.current && effect.current.wet) {
      effect.current.wet.value = wet;
    }
  }, [wet]);
  useEffect(function () {
    if (typeof low !== 'undefined' && effect.current && effect.current.low) {
      effect.current.low.value = low;
    }
  }, [low]);
  useEffect(function () {
    if (typeof mid !== 'undefined' && effect.current && effect.current.mid) {
      effect.current.mid.value = mid;
    }
  }, [mid]);
  useEffect(function () {
    if (typeof high !== 'undefined' && effect.current && effect.current.high) {
      effect.current.high.value = high;
    }
  }, [high]);
  useEffect(function () {
    if (typeof lowFrequency !== 'undefined' && effect.current && effect.current.lowFrequency) {
      effect.current.lowFrequency.value = lowFrequency;
    }
  }, [lowFrequency]);
  useEffect(function () {
    if (typeof highFrequency !== 'undefined' && effect.current && effect.current.highFrequency) {
      effect.current.highFrequency.value = highFrequency;
    }
  }, [highFrequency]);
  return null;
};

var Effect = function Effect(props) {
  var _useContext = useContext(TrackContext),
      onAddToEffectsChain = _useContext.onAddToEffectsChain,
      onRemoveFromEffectsChain = _useContext.onRemoveFromEffectsChain;

  return React.createElement(EffectConsumer, Object.assign({
    onAddToEffectsChain: onAddToEffectsChain,
    onRemoveFromEffectsChain: onRemoveFromEffectsChain
  }, props));
};

var instruments = [{
  id: 'amSynth',
  name: 'AM Synth',
  props: ['polyphony', 'oscillatorType']
}, {
  id: 'duoSynth',
  name: 'Duo Synth',
  props: ['polyphony', 'oscillatorType']
}, {
  id: 'fmSynth',
  name: 'FM Synth',
  props: ['polyphony', 'oscillatorType']
}, {
  id: 'membraneSynth',
  name: 'Membrane Synth',
  props: []
}, {
  id: 'metalSynth',
  name: 'Metal Synth',
  props: []
}, {
  id: 'monoSynth',
  name: 'Mono Synth',
  props: ['polyphony', 'oscillatorType']
}, // { id: 'noiseSynth', name: 'Noise Synth' }, // No sound, disabled for now
{
  id: 'pluckSynth',
  name: 'Pluck Synth',
  props: []
}, {
  id: 'sampler',
  name: 'Sampler',
  props: ['samples']
}, {
  id: 'synth',
  name: 'Synth',
  props: ['polyphony', 'oscillatorType']
}];
var effects = [// --------------------------------------------------------------------------
// Tone JS Effects
// --------------------------------------------------------------------------
{
  id: 'autoFilter',
  name: 'Auto Filter'
}, {
  id: 'autoPanner',
  name: 'Auto Panner'
}, {
  id: 'autoWah',
  name: 'Auto Wah'
}, {
  id: 'bitCrusher',
  name: 'Bit Crusher'
}, // { id: 'chorus', name: 'Chorus' },
{
  id: 'distortion',
  name: 'Distortion'
}, {
  id: 'feedbackDelay',
  name: 'Feedback Delay'
}, {
  id: 'freeverb',
  name: 'Freeverb'
}, {
  id: 'panVol',
  name: 'Volume/Pan'
}, // { id: 'reverb', name: 'Reverb' },
{
  id: 'tremolo',
  name: 'Tremolo'
}, // --------------------------------------------------------------------------
// Tone JS Components
// --------------------------------------------------------------------------
{
  id: 'eq3',
  name: 'EQ3'
}];
var config = {
  instruments: instruments,
  effects: effects
};
var midiNotes = ['C-2', 'C#-2', 'D-2', 'D#-2', 'E-2', 'F-2', 'F#-2', 'G-2', 'G#-2', 'A-2', 'A#-2', 'B-2', 'C-1', 'C#-1', 'D-1', 'D#-1', 'E-1', 'F-1', 'F#-1', 'G-1', 'G#-1', 'A-1', 'A#-1', 'B-1', 'C0', 'C#0', 'D0', 'D#0', 'E0', 'F0', 'F#0', 'G0', 'G#0', 'A0', 'A#0', 'B0', 'C1', 'C#1', 'D1', 'D#1', 'E1', 'F1', 'F#1', 'G1', 'G#1', 'A1', 'A#1', 'B1', 'C2', 'C#2', 'D2', 'D#2', 'E2', 'F2', 'F#2', 'G2', 'G#2', 'A2', 'A#2', 'B2', 'C3', 'C#3', 'D3', 'D#3', 'E3', 'F3', 'F#3', 'G3', 'G#3', 'A3', 'A#3', 'B3', 'C4', 'C#4', 'D4', 'D#4', 'E4', 'F4', 'F#4', 'G4', 'G#4', 'A4', 'A#4', 'B4', 'C5', 'C#5', 'D5', 'D#5', 'E5', 'F5', 'F#5', 'G5', 'G#5', 'A5', 'A#5', 'B5', 'C6', 'C#6', 'D6', 'D#6', 'E6', 'F6', 'F#6', 'G6', 'G#6', 'A6', 'A#6', 'B6', 'C7', 'C#7', 'D7', 'D#7', 'E7', 'F7', 'F#7', 'G7', 'G#7', 'A7', 'A#7', 'B7', 'C8', 'C#8', 'D8', 'D#8', 'E8', 'F8', 'F#8', 'G8'];

export { Effect, Instrument, Song, Track, config, midiNotes };
//# sourceMappingURL=reactronica.esm.js.map
